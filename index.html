<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflow Builder - Agentes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        .puzzle-piece-cell {
            position: absolute;
            border: 1px solid #9CA3AF;
        }
        
        .tool-piece-cell {
            position: absolute;
            border: 1px solid #1E40AF;
            box-shadow: 0 0 3px rgba(30, 64, 175, 0.3);
        }
        
        .orchestrator-piece-cell {
            position: absolute;
            border: 1px solid #7C2D12;
            box-shadow: 0 0 3px rgba(124, 45, 18, 0.3);
        }
        
        .dragging {
            opacity: 0.7;
        }
        
        .selected {
            box-shadow: 0 0 0 2px #3B82F6, 0 0 0 4px rgba(59, 130, 246, 0.2);
        }
        
        .component-item {
            cursor: move;
            transition: background-color 0.2s;
        }
        
        .component-item:hover {
            background-color: #F9FAFB;
        }
        
        .tool-item {
            cursor: move;
            transition: all 0.2s;
        }
        
        .tool-item:hover {
            background-color: #F0F9FF;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .tool-item.dragging {
            transform: rotate(5deg);
        }
        
        .canvas-grid {
            background-image: 
                linear-gradient(to right, #f0f0f0 1px, transparent 1px),
                linear-gradient(to bottom, #f0f0f0 1px, transparent 1px);
            background-size: 12px 12px;
        }
        
        .label-box {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid #E5E7EB;
            border-radius: 4px;
            padding: 4px 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .tool-label-box {
            background: rgba(59, 130, 246, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid #1E40AF;
            border-radius: 4px;
            padding: 4px 8px;
            box-shadow: 0 1px 3px rgba(30, 64, 175, 0.3);
            color: white;
        }
        
        .orchestrator-label-box {
            background: rgba(124, 45, 18, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid #7C2D12;
            border-radius: 4px;
            padding: 4px 8px;
            box-shadow: 0 1px 3px rgba(124, 45, 18, 0.3);
            color: white;
        }
        
        .drag-over {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .tool-compatible {
            background-color: rgba(34, 197, 94, 0.2) !important;
            border: 2px dashed #22C55E !important;
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-purple-600 text-white p-4">
        <h1 class="text-xl font-bold">Workflow Builder - Agentes</h1>
    </header>
    
    <!-- Main content -->
    <div class="flex-1 flex">
        <!-- Left Sidebar - Components -->
        <div class="w-80 bg-gray-100 border-r overflow-y-auto">
            <div class="p-4">
                <h2 class="font-semibold mb-4 text-gray-800">Componentes</h2>
                <div id="components-list" class="space-y-1">
                    <!-- Components will be rendered here -->
                </div>
            </div>
        </div>
        
        <!-- Canvas area -->
        <div class="flex-1 flex flex-col">
            <div class="p-4 border-b">
                <p class="text-gray-600">
                    <strong>Desafio:</strong> construa um workflow de...
                </p>
                <p class="text-sm text-gray-500 mt-1">
                    Arraste pe√ßas da barra lateral. Tools da direita encaixam no Call Tool ou Orquestrador!
                </p>
            </div>
            
            <div id="canvas" class="flex-1 bg-white relative overflow-hidden canvas-grid" tabindex="0">
                <div id="empty-message" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <p class="text-gray-400 text-lg">
                        Arraste os componentes e monte seu workflow aqui
                    </p>
                </div>
            </div>
            
            <div class="p-4 border-t bg-gray-50">
                <div class="flex gap-2 items-center">
                    <button id="validate-btn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded">
                        Validar Workflow
                    </button>
                    <button id="clear-btn" class="border border-gray-300 text-gray-600 px-4 py-2 rounded hover:bg-gray-50">
                        Limpar Canvas
                    </button>
                    <span id="selection-status" class="text-sm text-blue-600 ml-2 hidden">
                        Pe√ßa selecionada - pressione Delete para remover
                    </span>
                </div>
            </div>
        </div>
        
        <!-- Right Sidebar - Tools -->
        <div class="w-80 bg-blue-50 border-l overflow-y-auto">
            <div class="p-4">
                <h2 class="font-semibold mb-4 text-gray-800">üîß Tools Modulares</h2>
                <p class="text-xs text-gray-600 mb-4">Arraste para conectar ao Call Tool ou Orquestrador</p>
                <div id="tools-list" class="space-y-2">
                    <!-- Tool items will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Component data
        const componentTypes = [
            {
                id: 'user-input',
                name: 'User Input (Teams)',
                color: '#4B5563',
                inputType: null,
                outputType: 'text',
                shape: [
                    [1,1,1,1,1,1],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            },
            {
                id: 'ms-office',
                name: 'MS-Office, PDFs',
                color: '#4B5563',
                inputType: null,
                outputType: 'document',
                shape: [
                    [1,1,1,1,1,1],
                    [1,1,1,1,1,1],
                    [1,1,0,0,0,0],
                    [1,1,0,0,0,0]
                ]
            },
            {
                id: 'ligacoes',
                name: 'Liga√ß√µes, MP3',
                color: '#4B5563',
                inputType: null,
                outputType: 'audio',
                shape: [
                    [1,1,1,1,1,1],
                    [1,1,1,1,1,1],
                    [0,0,0,0,1,1],
                    [0,0,0,0,1,1]
                ]
            },
            {
                id: 'ocr',
                name: 'OCR',
                color: '#8B5CF6',
                inputType: 'document',
                outputType: 'text',
                shape: [
                    [0,0,1,1,1,1],
                    [0,0,1,1,1,1],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            },
            {
                id: 'tts',
                name: 'TTS - texto para fala',
                color: '#06B6D4',
                inputType: 'text',
                outputType: 'audio',
                shape: [
                    [1,1,0,0,1,1],
                    [1,1,0,0,1,1],
                    [1,1,1,1,1,1],
                    [0,0,0,0,1,1],
                    [0,0,0,0,1,1]
                ]
            },
            {
                id: 'stt',
                name: 'STT - Fala para texto',
                color: '#EAB308',
                inputType: 'audio',
                outputType: 'text',
                shape: [
                    [1,1,1,1,0,0],
                    [1,1,1,1,0,0],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            },
            {
                id: 'gerador-texto',
                name: 'gerador de texto',
                color: '#16A34A',
                inputType: 'text',
                outputType: 'text',
                shape: [
                    [1,1,0,0,1,1],
                    [1,1,0,0,1,1],
                    [1,1,1,1,1,1],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            },
            {
                id: 'rag',
                name: 'RAG - Busca bases',
                color: '#2563EB',
                inputType: 'text',
                outputType: 'text',
                shape: [
                    [1,1,0,0,1,1],
                    [1,1,0,0,1,1],
                    [1,1,1,1,1,1],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            },
            {
                id: 'calltool',
                name: 'Call Tool',
                color: '#FF0000',
                inputType: 'text',
                outputType: 'text',
                shape: [
                    [1,1,0,0,1,1],
                    [1,1,0,0,1,1],
                    [1,1,1,1,1,0],
                    [1,1,1,1,1,1],
                    [0,0,1,1,0,0],
                    [0,0,1,1,0,0]
                ]
            }
        ];

        // Tool data - Only 3 specific tools
        const toolItems = [
            {
                id: 'sendmail-tool',
                name: 'Sendmail Tool',
                description: 'Enviar emails automaticamente',
                endpoint: '/tools/sendmail',
                method: 'POST',
                color: '#10B981',
                shape: [
                    [0,1,1,1],
                    [0,1,1,1],
                    [1,1,1,1],
                    [0,1,1,1]
                ]
            },
            {
                id: 'pix-tool',
                name: 'PIX Tool',
                description: 'Processar pagamentos PIX',
                endpoint: '/tools/pix',
                method: 'POST',
                color: '#3B82F6',
                shape: [
                    [0,1,1,1],
                    [0,1,1,1],
                    [1,1,1,1],
                    [0,1,1,1]
                ]
            },
            {
                id: 'translate-tool',
                name: 'Traduzir Tool',
                description: 'Traduzir textos automaticamente',
                endpoint: '/tools/translate',
                method: 'POST',
                color: '#8B5CF6',
                shape: [
                    [0,1,1,1],
                    [0,1,1,1],
                    [1,1,1,1],
                    [0,1,1,1]
                ]
            },
            {
                id: 'orchestrator',
                name: 'Orquestrador',
                description: 'Conecta m√∫ltiplas tools em sequ√™ncia',
                endpoint: '/orchestrator',
                method: 'POST',
                color: '#DC2626',
                isOrchestrator: true,
                shape: [
                    [1,1], [1,1], [1,0], [1,1],
                    [1,1], [1,1], [1,0], [1,1],
                    [1,1], [1,1], [1,0], [1,1],
                    [1,1], [1,1], [1,0], [1,1]
                ]
            }
        ];

        // Global state
        let droppedComponents = [];
        let selectedPiece = null;
        let currentDragData = null;
        let draggedFromTool = false;

        // Constants
        const CELL_SIZE = 12;
        const GRID_SIZE = 12;

        // Utility functions
        function createPuzzlePiece(component, options = {}) {
            const { isDragging = false, isSelected = false, isTool = false, isOrchestrator = false } = options;
            
            const container = document.createElement('div');
            container.className = `relative ${isDragging ? 'opacity-70' : ''} ${isSelected ? 'selected' : ''}`;
            container.style.width = `${component.shape[0].length * CELL_SIZE}px`;
            container.style.height = `${component.shape.length * CELL_SIZE}px`;
            
            component.shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell === 1) {
                        const cellDiv = document.createElement('div');
                        if (isOrchestrator) {
                            cellDiv.className = 'orchestrator-piece-cell';
                        } else if (isTool) {
                            cellDiv.className = 'tool-piece-cell';
                        } else {
                            cellDiv.className = 'puzzle-piece-cell';
                        }
                        cellDiv.style.backgroundColor = component.color;
                        cellDiv.style.left = `${colIndex * CELL_SIZE}px`;
                        cellDiv.style.top = `${rowIndex * CELL_SIZE}px`;
                        cellDiv.style.width = `${CELL_SIZE}px`;
                        cellDiv.style.height = `${CELL_SIZE}px`;
                        if (isSelected) {
                            cellDiv.style.borderColor = '#3B82F6';
                        }
                        container.appendChild(cellDiv);
                    }
                });
            });
            
            return container;
        }

        function canPiecesInterlock(piece1, pos1, piece2, pos2) {
            const grid1X = Math.round(pos1.x / CELL_SIZE);
            const grid1Y = Math.round(pos1.y / CELL_SIZE);
            const grid2X = Math.round(pos2.x / CELL_SIZE);
            const grid2Y = Math.round(pos2.y / CELL_SIZE);
            
            for (let row1 = 0; row1 < piece1.shape.length; row1++) {
                for (let col1 = 0; col1 < piece1.shape[row1].length; col1++) {
                    const globalRow = grid1Y + row1;
                    const globalCol = grid1X + col1;
                    
                    for (let row2 = 0; row2 < piece2.shape.length; row2++) {
                        for (let col2 = 0; col2 < piece2.shape[row2].length; col2++) {
                            const piece2GlobalRow = grid2Y + row2;
                            const piece2GlobalCol = grid2X + col2;
                            
                            if (globalRow === piece2GlobalRow && globalCol === piece2GlobalCol) {
                                const piece1Cell = piece1.shape[row1][col1];
                                const piece2Cell = piece2.shape[row2][col2];
                                
                                if (piece1Cell === 1 && piece2Cell === 1) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        function canToolConnect(toolPiece, toolPos, targetPiece, targetPos) {
            // Tools can connect to Call Tools or Orchestrators
            if (targetPiece.id.includes('calltool') || targetPiece.isOrchestrator) {
                return canPiecesInterlock(toolPiece, toolPos, targetPiece, targetPos);
            }
            return false;
        }

        function getDropPosition(movingPiece, dropPos, existingPieces) {
            const snappedX = Math.round(dropPos.x / GRID_SIZE) * GRID_SIZE;
            const snappedY = Math.round(dropPos.y / GRID_SIZE) * GRID_SIZE;
            
            const testPos = { x: snappedX, y: snappedY };
            
            // Special handling for Tool pieces
            if (movingPiece.isTool || movingPiece.isOrchestrator) {
                const compatibleTargets = existingPieces.filter(p => 
                    p.id.includes('calltool') || p.isOrchestrator
                );
                
                if (compatibleTargets.length === 0) {
                    return testPos;
                }
                
                // Try to snap to compatible targets
                for (const target of compatibleTargets) {
                    const distance = Math.sqrt(
                        Math.pow(testPos.x - target.x, 2) + 
                        Math.pow(testPos.y - target.y, 2)
                    );
                    
                    if (distance < 100) {
                        // For Call Tool, try to fit on the left side
                        if (target.id.includes('calltool')) {
                            const perfectFitPos = {
                                x: target.x + (2 * CELL_SIZE),
                                y: target.y
                            };
                            
                            if (canToolConnect(movingPiece, perfectFitPos, target, target)) {
                                return perfectFitPos;
                            }
                        }
                        
                        // Try other positions around the target
                        const snapPositions = [
                            { x: target.x - (4 * CELL_SIZE), y: target.y },
                            { x: target.x + (6 * CELL_SIZE), y: target.y },
                            { x: target.x, y: target.y - (4 * CELL_SIZE) },
                            { x: target.x, y: target.y + (6 * CELL_SIZE) },
                        ];
                        
                        for (const snapPos of snapPositions) {
                            if (canToolConnect(movingPiece, snapPos, target, target)) {
                                return snapPos;
                            }
                        }
                    }
                }
            }
            
            // Regular collision detection
            for (const existingPiece of existingPieces) {
                if (!canPiecesInterlock(movingPiece, testPos, existingPiece, existingPiece)) {
                    const nearbyPositions = [
                        { x: snappedX + GRID_SIZE, y: snappedY },
                        { x: snappedX - GRID_SIZE, y: snappedY },
                        { x: snappedX, y: snappedY + GRID_SIZE },
                        { x: snappedX, y: snappedY - GRID_SIZE }
                    ];
                    
                    for (const nearbyPos of nearbyPositions) {
                        let canPlaceHere = true;
                        for (const piece of existingPieces) {
                            if (!canPiecesInterlock(movingPiece, nearbyPos, piece, piece)) {
                                canPlaceHere = false;
                                break;
                            }
                        }
                        if (canPlaceHere) {
                            return nearbyPos;
                        }
                    }
                }
            }
            
            return testPos;
        }

        function renderSidebarComponents() {
            const componentsList = document.getElementById('components-list');
            componentsList.innerHTML = '';
            
            componentTypes.forEach(component => {
                const item = document.createElement('div');
                item.className = 'mb-3 flex items-center gap-3 p-2 rounded-lg component-item';
                item.draggable = true;
                
                const pieceContainer = document.createElement('div');
                pieceContainer.className = 'flex-shrink-0';
                pieceContainer.appendChild(createPuzzlePiece(component));
                
                const label = document.createElement('div');
                label.className = 'flex-1 min-w-0';
                label.innerHTML = `<p class="text-sm font-medium text-gray-800 leading-tight">${component.name}</p>`;
                
                item.appendChild(pieceContainer);
                item.appendChild(label);
                
                // Drag events
                item.addEventListener('dragstart', (e) => {
                    console.log('Drag started for component:', component.name);
                    currentDragData = component;
                    draggedFromTool = false;
                    item.classList.add('dragging');
                    
                    e.dataTransfer.setData('text/plain', JSON.stringify(component));
                    e.dataTransfer.effectAllowed = 'copy';
                });
                
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    currentDragData = null;
                    draggedFromTool = false;
                });
                
                componentsList.appendChild(item);
            });
        }

        function renderToolItems() {
            const toolsList = document.getElementById('tools-list');
            toolsList.innerHTML = '';
            
            toolItems.forEach(toolItem => {
                const item = document.createElement('div');
                item.className = 'p-3 bg-white rounded-lg border border-blue-200 tool-item mb-2';
                item.draggable = true;
                
                // Only show preview for non-orchestrator items (they're too long)
                let previewHtml = '';
                if (!toolItem.isOrchestrator) {
                    const previewContainer = document.createElement('div');
                    previewContainer.className = 'flex items-center gap-2 mb-2';
                    
                    const miniPiece = createPuzzlePiece(toolItem, { isTool: true });
                    miniPiece.style.transform = 'scale(0.8)';
                    miniPiece.style.transformOrigin = 'top left';
                    
                    const previewWrapper = document.createElement('div');
                    previewWrapper.className = 'flex-shrink-0';
                    previewWrapper.style.width = '40px';
                    previewWrapper.style.height = '40px';
                    previewWrapper.appendChild(miniPiece);
                    
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'flex-1';
                    titleDiv.innerHTML = `
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold text-gray-800">${toolItem.name}</h3>
                            <span class="text-xs px-2 py-1 rounded bg-blue-100 text-blue-800">${toolItem.method}</span>
                        </div>
                    `;
                    
                    previewContainer.appendChild(previewWrapper);
                    previewContainer.appendChild(titleDiv);
                    item.appendChild(previewContainer);
                } else {
                    // For orchestrator, just show title without preview
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'mb-2';
                    titleDiv.innerHTML = `
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold text-gray-800">${toolItem.name}</h3>
                            <span class="text-xs px-2 py-1 rounded bg-red-100 text-red-800">${toolItem.method}</span>
                        </div>
                    `;
                    item.appendChild(titleDiv);
                }
                
                const descDiv = document.createElement('div');
                const connectText = toolItem.isOrchestrator ? 
                    'üéõÔ∏è Conecta m√∫ltiplas tools' : 
                    'üß© Encaixa no Call Tool';
                
                descDiv.innerHTML = `
                    <p class="text-xs text-gray-600 mb-2">${toolItem.description}</p>
                    <code class="text-xs bg-gray-100 px-2 py-1 rounded block">${toolItem.endpoint}</code>
                    <div class="mt-2 text-xs text-blue-600">${connectText}</div>
                `;
                
                item.appendChild(descDiv);
                
                // Drag events
                item.addEventListener('dragstart', (e) => {
                    console.log('Drag started for tool:', toolItem.name);
                    const toolAsComponent = {
                        ...toolItem,
                        isTool: !toolItem.isOrchestrator,
                        inputType: 'calltool',
                        outputType: 'tool'
                    };
                    currentDragData = toolAsComponent;
                    draggedFromTool = true;
                    item.classList.add('dragging');
                    
                    e.dataTransfer.setData('text/plain', JSON.stringify(toolAsComponent));
                    e.dataTransfer.effectAllowed = 'copy';
                });
                
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    currentDragData = null;
                    draggedFromTool = false;
                });
                
                toolsList.appendChild(item);
            });
        }

        function renderCanvasComponents() {
            const canvas = document.getElementById('canvas');
            const emptyMessage = document.getElementById('empty-message');
            
            // Clear existing components
            const existingComponents = canvas.querySelectorAll('.canvas-component');
            existingComponents.forEach(comp => comp.remove());
            
            if (droppedComponents.length === 0) {
                emptyMessage.style.display = 'flex';
            } else {
                emptyMessage.style.display = 'none';
                
                droppedComponents.forEach(component => {
                    const container = document.createElement('div');
                    container.className = 'absolute cursor-move canvas-component flex items-center gap-2';
                    container.style.left = `${component.x}px`;
                    container.style.top = `${component.y}px`;
                    container.style.zIndex = selectedPiece === component.id ? '10' : '1';
                    
                    const piece = createPuzzlePiece(component, { 
                        isSelected: selectedPiece === component.id,
                        isTool: component.isTool,
                        isOrchestrator: component.isOrchestrator
                    });
                    
                    const label = document.createElement('div');
                    if (component.isOrchestrator) {
                        label.className = 'orchestrator-label-box';
                    } else if (component.isTool) {
                        label.className = 'tool-label-box';
                    } else {
                        label.className = 'label-box';
                    }
                    label.innerHTML = `<p class="text-xs font-medium whitespace-nowrap">${component.name}</p>`;
                    
                    // Special positioning for different component types
                    if (component.id.includes('calltool')) {
                        // Call Tool: Label to the LEFT (will look strange but won't block tools)
                        label.style.order = '1';
                        piece.style.order = '2';
                        container.style.flexDirection = 'row';
                    } else if (component.isOrchestrator) {
                        // Orchestrator: Label to the LEFT (because it's very long)
                        label.style.order = '1';
                        piece.style.order = '2';
                        container.style.flexDirection = 'row';
                    } else {
                        // All other components (including tools): Label to the RIGHT
                        piece.style.order = '1';
                        label.style.order = '2';
                        container.style.flexDirection = 'row';
                    }
                    
                    container.appendChild(piece);
                    container.appendChild(label);
                    
                    // Mouse events for selection and dragging
                    let isDragging = false;
                    let dragOffset = { x: 0, y: 0 };
                    
                    container.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        selectPiece(component.id);
                        
                        const rect = canvas.getBoundingClientRect();
                        dragOffset.x = e.clientX - rect.left - component.x;
                        dragOffset.y = e.clientY - rect.top - component.y;
                        
                        isDragging = true;
                        
                        const handleMouseMove = (e) => {
                            if (!isDragging) return;
                            
                            const rect = canvas.getBoundingClientRect();
                            const newX = e.clientX - rect.left - dragOffset.x;
                            const newY = e.clientY - rect.top - dragOffset.y;
                            
                            const otherPieces = droppedComponents.filter(p => p.id !== component.id);
                            const finalPos = getDropPosition(component, { x: newX, y: newY }, otherPieces);
                            
                            updateComponentPosition(component.id, finalPos.x, finalPos.y);
                        };
                        
                        const handleMouseUp = () => {
                            isDragging = false;
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    });
                    
                    canvas.appendChild(container);
                });
            }
        }

        function selectPiece(pieceId) {
            selectedPiece = pieceId;
            updateSelectionStatus();
            renderCanvasComponents();
        }

        function updateSelectionStatus() {
            const status = document.getElementById('selection-status');
            if (selectedPiece) {
                status.classList.remove('hidden');
            } else {
                status.classList.add('hidden');
            }
        }

        function updateComponentPosition(componentId, newX, newY) {
            const component = droppedComponents.find(c => c.id === componentId);
            if (component) {
                component.x = newX;
                component.y = newY;
                renderCanvasComponents();
            }
        }

        function addComponentToCanvas(component, x, y) {
            const finalPos = getDropPosition(component, { x, y }, droppedComponents);
            
            const newComponent = {
                ...component,
                id: `${component.id}-${Date.now()}`,
                x: finalPos.x,
                y: finalPos.y
            };
            
            droppedComponents.push(newComponent);
            renderCanvasComponents();
            
            // Special messages
            if (component.isTool) {
                const callTools = droppedComponents.filter(p => p.id.includes('calltool'));
                const orchestrators = droppedComponents.filter(p => p.isOrchestrator);
                if (callTools.length === 0 && orchestrators.length === 0) {
                    setTimeout(() => {
                        alert('üí° Dica: Esta tool foi projetada para encaixar no Call Tool ou Orquestrador! Adicione um deles para conectar.');
                    }, 500);
                }
            } else if (component.isOrchestrator) {
                setTimeout(() => {
                    alert('üéõÔ∏è Orquestrador adicionado! Voc√™ pode conectar m√∫ltiplas tools nele para criar fluxos complexos.');
                }, 500);
            }
        }

        function removeComponent(componentId) {
            if (componentId === 'all') {
                droppedComponents = [];
                selectedPiece = null;
            } else {
                droppedComponents = droppedComponents.filter(c => c.id !== componentId);
                if (selectedPiece === componentId) {
                    selectedPiece = null;
                }
            }
            updateSelectionStatus();
            renderCanvasComponents();
        }

        function validateWorkflow() {
            if (droppedComponents.length === 0) {
                alert('Adicione pelo menos um componente ao workflow!');
                return;
            }
            
            const hasInput = droppedComponents.some(c => c.inputType === null);
            const callTools = droppedComponents.filter(c => c.id.includes('calltool'));
            const orchestrators = droppedComponents.filter(c => c.isOrchestrator);
            const tools = droppedComponents.filter(c => c.isTool);
            let interlockCount = 0;
            let toolConnections = 0;
            
            // Count connections
            for (let i = 0; i < droppedComponents.length; i++) {
                for (let j = i + 1; j < droppedComponents.length; j++) {
                    const distance = Math.sqrt(
                        Math.pow(droppedComponents[i].x - droppedComponents[j].x, 2) + 
                        Math.pow(droppedComponents[i].y - droppedComponents[j].y, 2)
                    );
                    
                    if (distance < 60) {
                        const piece1 = droppedComponents[i];
                        const piece2 = droppedComponents[j];
                        
                        // Check for Tool connections
                        if ((piece1.isTool && (piece2.id.includes('calltool') || piece2.isOrchestrator)) || 
                            (piece2.isTool && (piece1.id.includes('calltool') || piece1.isOrchestrator))) {
                            if (canPiecesInterlock(piece1, piece1, piece2, piece2)) {
                                toolConnections++;
                            }
                        } else if (canPiecesInterlock(piece1, piece1, piece2, piece2)) {
                            interlockCount++;
                        }
                    }
                }
            }
            
            if (!hasInput) {
                alert('‚ö†Ô∏è Adicione pelo menos um componente de entrada (User Input, MS-Office, ou Liga√ß√µes)');
                return;
            }
            
            let message = `‚úÖ Workflow analisado!\n`;
            message += `üß© Encaixes regulares: ${interlockCount}\n`;
            message += `üîß Tools conectadas: ${toolConnections}\n`;
            message += `üìä Call Tools: ${callTools.length}\n`;
            message += `üéõÔ∏è Orquestradores: ${orchestrators.length}\n`;
            message += `üõ†Ô∏è Tools: ${tools.length}`;
            
            if (toolConnections > 0) {
                message += `\n\nüéâ Excelente! Voc√™ conectou ${toolConnections} tool(s)! O sistema modular est√° funcionando!`;
            } else if (tools.length > 0 && (callTools.length === 0 && orchestrators.length === 0)) {
                message += `\n\nüí° Dica: Adicione Call Tools ou Orquestradores para conectar suas tools!`;
            } else if (interlockCount > 0) {
                message += `\n\n‚úÖ Workflow v√°lido com encaixes funcionais!`;
            } else {
                message += `\n\n‚ö†Ô∏è Tente conectar as pe√ßas para criar um fluxo funcional.`;
            }
            
            alert(message);
        }

        // Event listeners
        function setupEventListeners() {
            const canvas = document.getElementById('canvas');
            const validateBtn = document.getElementById('validate-btn');
            const clearBtn = document.getElementById('clear-btn');
            
            // Canvas drag and drop
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                
                if (draggedFromTool) {
                    const compatibleTargets = droppedComponents.filter(p => 
                        p.id.includes('calltool') || p.isOrchestrator
                    );
                    if (compatibleTargets.length > 0) {
                        canvas.classList.add('tool-compatible');
                    } else {
                        canvas.classList.add('drag-over');
                    }
                } else {
                    canvas.classList.add('drag-over');
                }
            });
            
            canvas.addEventListener('dragleave', (e) => {
                canvas.classList.remove('drag-over', 'tool-compatible');
            });
            
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                canvas.classList.remove('drag-over', 'tool-compatible');
                
                let componentData = null;
                
                try {
                    const transferData = e.dataTransfer.getData('text/plain');
                    if (transferData) {
                        componentData = JSON.parse(transferData);
                    }
                } catch (err) {
                    console.log('Error parsing transfer data:', err);
                }
                
                if (!componentData && currentDragData) {
                    componentData = currentDragData;
                }
                
                if (componentData) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    addComponentToCanvas(componentData, x, y);
                }
            });
            
            // Canvas click to deselect
            canvas.addEventListener('click', (e) => {
                if (e.target === canvas) {
                    selectedPiece = null;
                    updateSelectionStatus();
                    renderCanvasComponents();
                }
            });
            
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedPiece) {
                    e.preventDefault();
                    removeComponent(selectedPiece);
                }
            });
            
            // Button events
            validateBtn.addEventListener('click', validateWorkflow);
            clearBtn.addEventListener('click', () => removeComponent('all'));
            
            canvas.focus();
        }

        // Initialize application
        function init() {
            console.log('Initializing workflow builder with fixed label positioning...');
            renderSidebarComponents();
            renderToolItems();
            renderCanvasComponents();
            setupEventListeners();
            console.log('Workflow builder with fixed label positioning initialized!');
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

